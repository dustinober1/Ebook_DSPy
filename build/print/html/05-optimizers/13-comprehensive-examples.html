<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Comprehensive Examples - DSPy: A Practical Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="The most comprehensive DSPy guide with complete coverage of 9 research papers, advanced optimization techniques, and production-ready applications">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon-de23e50b.svg">
        <link rel="shortcut icon" href="../favicon-8114d1fc.png">
        <link rel="stylesheet" href="../css/variables-8adf115d.css">
        <link rel="stylesheet" href="../css/general-2459343d.css">
        <link rel="stylesheet" href="../css/chrome-ae938929.css">
        <link rel="stylesheet" href="../css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="../highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="../tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="../ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../assets/print-only-ef201963.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc-4ea68664.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">DSPy: A Practical Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="comprehensive-examples-and-implementation-guide"><a class="header" href="#comprehensive-examples-and-implementation-guide">Comprehensive Examples and Implementation Guide</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>This section brings together all the optimization techniques we’ve explored—COPA, joint optimization, Monte Carlo methods, and Bayesian optimization—through comprehensive, real-world examples. These examples demonstrate how to apply these techniques to complex DSPy applications and provide practical guidance for implementation.</p>
<h3 id="learning-objectives"><a class="header" href="#learning-objectives">Learning Objectives</a></h3>
<p>By the end of this section, you will:</p>
<ul>
<li>Apply advanced optimization techniques to real-world scenarios</li>
<li>Implement hybrid optimization strategies combining multiple methods</li>
<li>Master the end-to-end optimization workflow</li>
<li>Understand trade-offs and decision points in optimization</li>
<li>Build production-ready optimization pipelines</li>
</ul>
<h2 id="example-1-enterprise-rag-system-optimization"><a class="header" href="#example-1-enterprise-rag-system-optimization">Example 1: Enterprise RAG System Optimization</a></h2>
<h3 id="problem-setup"><a class="header" href="#problem-setup">Problem Setup</a></h3>
<p>We’ll optimize a complex Retrieval-Augmented Generation (RAG) system for enterprise knowledge management that needs to:</p>
<ul>
<li>Answer domain-specific questions accurately</li>
<li>Maintain consistency with company guidelines</li>
<li>Handle multiple document types</li>
<li>Operate efficiently at scale</li>
</ul>
<h3 id="complete-implementation"><a class="header" href="#complete-implementation">Complete Implementation</a></h3>
<pre><code class="language-python">import dspy
from typing import List, Dict, Any
import numpy as np
from dataclasses import dataclass

# Define the RAG system components
@dataclass
class RAGSystemConfig:
    """Configuration for RAG system optimization."""

    # Retrieval parameters
    retrieval_method: str = "hybrid"  # semantic, keyword, hybrid
    top_k: int = 5
    reranker_type: str = "cross_encoder"

    # Generation parameters
    instruction_style: str = "professional"
    include_context_summary: bool = True
    citation_style: str = "inline"
    response_length: str = "medium"  # short, medium, long

    # Advanced features
    use_multi_hop: bool = True
    self_reflection: bool = True
    confidence_threshold: float = 0.7

    # Model parameters
    temperature: float = 0.3
    max_tokens: int = 300

class EnterpriseRAGSystem(dspy.Module):
    """Enterprise-grade RAG system with multiple optimization targets."""

    def __init__(self, config: RAGSystemConfig):
        super().__init__()
        self.config = config

        # Initialize components
        self.query_processor = dspy.ChainOfThought(ProcessQuerySignature())
        self.retriever = self._create_retriever()
        self.reranker = self._create_reranker()
        self.context_synthesizer = dspy.ChainOfThought(SynthesizeContextSignature())
        self.generator = dspy.ChainOfThought(GenerateAnswerSignature())
        self.validator = self._create_validator()

    def _create_retriever(self):
        """Create retriever based on configuration."""
        if self.config.retrieval_method == "semantic":
            return dspy.Retrieve(k=self.config.top_k)
        elif self.config.retrieval_method == "hybrid":
            return HybridRetriever(k=self.config.top_k)
        else:
            return KeywordRetriever(k=self.config.top_k)

    def forward(self, question: str, domain: str = None) -&gt; dspy.Prediction:
        """Forward pass through the RAG system."""

        # Step 1: Process and enhance query
        if domain:
            processed_query = self.query_processor(
                question=question,
                domain_context=get_domain_context(domain)
            )
            enhanced_query = processed_query.enhanced_query
        else:
            enhanced_query = question

        # Step 2: Retrieve relevant documents
        retrieved_docs = self.retriever(enhanced_query).passages

        # Step 3: Rerank documents if configured
        if self.config.reranker_type:
            ranked_docs = self.reranker(
                query=enhanced_query,
                documents=retrieved_docs
            )
            top_docs = ranked_docs.ranked_passages[:self.config.top_k]
        else:
            top_docs = retrieved_docs

        # Step 4: Synthesize context
        if self.config.include_context_summary:
            context = self.context_synthesizer(
                documents=top_docs,
                query=enhanced_query
            )
            synthesized_context = context.summary
        else:
            synthesized_context = "\n".join(top_docs)

        # Step 5: Generate answer
        instruction = self._build_instruction()
        answer = self.generator(
            instruction=instruction,
            context=synthesized_context,
            question=question
        )

        # Step 6: Self-reflection if enabled
        if self.config.self_reflection:
            reflection = self.validate_and_refine(
                question, answer.answer, synthesized_context
            )
            final_answer = reflection.refined_answer or answer.answer
            confidence = reflection.confidence
        else:
            final_answer = answer.answer
            confidence = 0.8  # Default confidence

        return dspy.Prediction(
            answer=final_answer,
            context=top_docs,
            confidence=confidence,
            reasoning=answer.rationale
        )

    def _build_instruction(self) -&gt; str:
        """Build instruction based on configuration."""
        base_instructions = {
            "professional": "Provide a professional, well-structured response suitable for enterprise communication.",
            "conversational": "Provide a helpful, conversational response that is easy to understand.",
            "technical": "Provide a detailed technical response with specific information."
        }

        instruction = base_instructions.get(
            self.config.instruction_style,
            base_instructions["professional"]
        )

        # Add citation requirement
        if self.config.citation_style == "inline":
            instruction += " Include inline citations to the sources used."

        # Add length guidance
        length_guidance = {
            "short": "Keep your response concise and to the point (2-3 sentences).",
            "medium": "Provide a comprehensive response (1-2 paragraphs).",
            "long": "Provide a detailed, thorough response with multiple paragraphs."
        }
        instruction += " " + length_guidance.get(
            self.config.response_length,
            length_guidance["medium"]
        )

        return instruction

# Multi-objective optimization for RAG system
class RAGMultiObjectiveOptimizer:
    """Multi-objective optimizer for RAG systems."""

    def __init__(self, base_system: EnterpriseRAGSystem):
        self.base_system = base_system
        self.objectives = {
            "accuracy": self._evaluate_accuracy,
            "latency": self._evaluate_latency,
            "cost": self._evaluate_cost,
            "user_satisfaction": self._evaluate_user_satisfaction
        }

    def optimize(self, trainset, valset, optimization_budget=200):
        """Execute multi-objective optimization using Bayesian optimization."""

        # Define search space
        search_space = {
            "retrieval_method": {"type": "categorical", "values": ["semantic", "hybrid", "keyword"]},
            "top_k": {"type": "discrete", "values": [3, 5, 7, 10]},
            "reranker_type": {"type": "categorical", "values": ["none", "cross_encoder", "monoT5"]},
            "instruction_style": {"type": "categorical", "values": ["professional", "conversational", "technical"]},
            "temperature": {"type": "continuous", "bounds": [0.1, 1.0]},
            "max_tokens": {"type": "discrete", "values": [150, 300, 500, 750]},
            "use_multi_hop": {"type": "categorical", "values": [True, False]},
            "self_reflection": {"type": "categorical", "values": [True, False]}
        }

        # Create multi-objective Bayesian optimizer
        optimizer = MultiObjectiveBayesianOptimizer(
            objectives=list(self.objectives.keys()),
            task_signature=None,  # Custom evaluation
            trainset=trainset,
            valset=valset,
            metric_fns=self.objectives,
            search_space=search_space,
            preference_weights={
                "accuracy": 0.4,
                "latency": 0.2,
                "cost": 0.2,
                "user_satisfaction": 0.2
            }
        )

        # Run optimization
        pareto_front = optimizer.optimize(max_iterations=optimization_budget)

        # Analyze and select best configuration
        best_config = self._select_best_configuration(pareto_front)

        return best_config, pareto_front

    def _evaluate_accuracy(self, config, valset):
        """Evaluate accuracy of RAG system with given config."""
        # Create system with config
        system = self._create_system_with_config(config)

        # Evaluate on validation set
        correct = 0
        total = 0

        for example in valset:
            pred = system(question=example.question, domain=example.domain)

            # Multiple accuracy metrics
            answer_correctness = evaluate_answer_correctness(
                pred.answer, example.answer
            )
            faithfulness = evaluate_faithfulness(
                pred.answer, pred.context
            )

            # Combined accuracy score
            accuracy = 0.6 * answer_correctness + 0.4 * faithfulness

            if accuracy &gt; 0.8:  # Threshold for correct
                correct += 1
            total += 1

        return correct / total

    def _evaluate_latency(self, config, valset):
        """Evaluate latency of RAG system."""
        system = self._create_system_with_config(config)

        # Measure average latency
        latencies = []
        for example in valset[:20]:  # Sample for efficiency
            start_time = time.time()
            system(question=example.question)
            end_time = time.time()
            latencies.append(end_time - start_time)

        # Return average latency (lower is better, so we negate)
        return -np.mean(latencies)

    def _evaluate_cost(self, config, valset):
        """Estimate operational cost."""
        # Calculate cost based on configuration
        cost = 0

        # Retrieval cost
        if config["retrieval_method"] == "hybrid":
            cost += config["top_k"] * 0.001
        else:
            cost += config["top_k"] * 0.0005

        # Reranking cost
        if config["reranker_type"] == "cross_encoder":
            cost += config["top_k"] * 0.01
        elif config["reranker_type"] == "monoT5":
            cost += config["top_k"] * 0.02

        # Generation cost
        cost += config["max_tokens"] * 0.00001

        # Multi-hop cost
        if config["use_multi_hop"]:
            cost *= 1.5

        # Self-reflection cost
        if config["self_reflection"]:
            cost *= 1.3

        # Return negative cost (lower is better)
        return -cost

# Run the optimization
def optimize_enterprise_rag():
    """Complete optimization pipeline for enterprise RAG."""

    print("=== Enterprise RAG System Optimization ===\n")

    # 1. Load data
    print("Loading enterprise knowledge base and queries...")
    trainset = load_enterprise_queries(split="train", size=500)
    valset = load_enterprise_queries(split="val", size=200)

    # 2. Initialize base system
    print("Initializing base RAG system...")
    base_config = RAGSystemConfig()
    base_system = EnterpriseRAGSystem(base_config)

    # 3. Create optimizer
    print("Setting up multi-objective optimizer...")
    optimizer = RAGMultiObjectiveOptimizer(base_system)

    # 4. Run optimization
    print("Running multi-objective optimization...")
    best_config, pareto_front = optimizer.optimize(
        trainset=trainset,
        valset=valset,
        optimization_budget=300
    )

    # 5. Analyze results
    print("\n=== Optimization Results ===")
    print(f"Best configuration:")
    for key, value in best_config.items():
        print(f"  {key}: {value}")

    print("\nPareto front solutions:")
    for i, solution in enumerate(pareto_front[:5]):  # Top 5 solutions
        print(f"\nSolution {i+1}:")
        for obj, score in solution.items():
            if obj != "config":
                print(f"  {obj}: {score:.4f}")

    # 6. Create final system
    print("\nCreating optimized RAG system...")
    final_system = EnterpriseRAGSystem(
        RAGSystemConfig(**best_config)
    )

    # 7. Final evaluation
    print("Running final evaluation...")
    test_results = comprehensive_evaluation(final_system)

    return final_system, best_config, test_results

def comprehensive_evaluation(system):
    """Comprehensive evaluation of optimized system."""

    testset = load_enterprise_queries(split="test")

    metrics = {
        "accuracy": 0,
        "latency_ms": 0,
        "cost_per_query": 0,
        "user_satisfaction": 0,
        "coverage": 0
    }

    # Run evaluations
    for example in testset:
        start = time.time()
        pred = system(question=example.question, domain=example.domain)
        latency = (time.time() - start) * 1000

        # Update metrics
        metrics["accuracy"] += evaluate_answer_quality(example, pred)
        metrics["latency_ms"] += latency
        metrics["cost_per_query"] += estimate_query_cost(pred)
        metrics["user_satisfaction"] += simulate_user_rating(example, pred)
        metrics["coverage"] += 1 if pred.confidence &gt; 0.5 else 0

    # Average metrics
    for key in metrics:
        metrics[key] /= len(testset)

    return metrics
</code></pre>
<h2 id="example-2-multi-language-code-generation-system"><a class="header" href="#example-2-multi-language-code-generation-system">Example 2: Multi-Language Code Generation System</a></h2>
<h3 id="problem-setup-1"><a class="header" href="#problem-setup-1">Problem Setup</a></h3>
<p>Optimizing a code generation system that:</p>
<ul>
<li>Supports multiple programming languages</li>
<li>Generates efficient, clean code</li>
<li>Follows language-specific best practices</li>
<li>Handles complex algorithmic problems</li>
</ul>
<h3 id="implementation-with-joint-optimization"><a class="header" href="#implementation-with-joint-optimization">Implementation with Joint Optimization</a></h3>
<pre><code class="language-python">class MultiLanguageCodeGenerator(dspy.Module):
    """Multi-language code generation system with joint optimization."""

    def __init__(self, languages: List[str]):
        super().__init__()
        self.languages = languages

        # Language-specific components
        self.language_detectors = {
            lang: dspy.Predict(DetectLanguageSignature())
            for lang in languages
        }

        self.code_generators = {
            lang: dspy.ChainOfThought(GenerateCodeSignature())
            for lang in languages
        }

        self.code_optimizers = {
            lang: CodeOptimizer(lang)
            for lang in languages
        }

        # Learnable prompt templates
        self.prompt_templates = LearnablePromptTemplates(languages)

        # Joint parameters
        self.temperature = torch.nn.Parameter(torch.tensor(0.7))
        self.complexity_threshold = torch.nn.Parameter(torch.tensor(0.5))

    def forward(self, requirements: str, language: str = None) -&gt; dspy.Prediction:
        """Generate code in specified or detected language."""

        # Detect language if not specified
        if not language:
            detection = self._detect_language(requirements)
            language = detection.language
            confidence = detection.confidence
        else:
            confidence = 1.0

        # Get language-specific prompt
        prompt = self.prompt_templates.get_prompt(language, requirements)

        # Generate initial code
        generator = self.code_generators[language]
        initial_code = generator(
            requirements=requirements,
            prompt=prompt,
            temperature=self.temperature.item()
        )

        # Optimize code
        optimizer = self.code_optimizers[language]
        optimized_code = optimizer.optimize(
            initial_code.code,
            complexity_threshold=self.complexity_threshold.item()
        )

        # Generate explanation
        explanation = self._generate_explanation(
            optimized_code.code,
            language,
            requirements
        )

        return dspy.Prediction(
            code=optimized_code.code,
            language=language,
            language_confidence=confidence,
            explanation=explanation,
            complexity=optimized_code.complexity,
            optimizations=optimized_code.applied_optimizations
        )

class JointCodeOptimizer:
    """Joint optimizer for code generation system."""

    def __init__(self, system: MultiLanguageCodeGenerator):
        self.system = system
        self.training_data = {}
        self.validation_data = {}

    def optimize(
        self,
        multi_lang_trainset: Dict[str, List],
        multi_lang_valset: Dict[str, List],
        optimization_config: Dict
    ):
        """Execute joint optimization across languages."""

        print("=== Joint Multi-Language Optimization ===\n")

        # Phase 1: Language-specific fine-tuning
        print("Phase 1: Language-specific fine-tuning...")
        language_models = {}

        for language in self.system.languages:
            print(f"\nFine-tuning for {language}...")

            # Fine-tune language-specific model
            language_models[language] = self._fine_tune_language_model(
                language,
                multi_lang_trainset[language],
                multi_lang_valset[language]
            )

        # Phase 2: Cross-language knowledge transfer
        print("\nPhase 2: Cross-language knowledge transfer...")
        shared_knowledge = self._extract_cross_language_knowledge(language_models)

        # Phase 3: Prompt optimization
        print("\nPhase 3: Joint prompt optimization...")
        optimized_prompts = self._optimize_prompts_jointly(
            multi_lang_trainset,
            multi_lang_valset,
            shared_knowledge
        )

        # Phase 4: Parameter optimization
        print("\nPhase 4: Joint parameter optimization...")
        optimized_params = self._optimize_parameters_jointly(
            language_models,
            optimized_prompts
        )

        # Create optimized system
        optimized_system = self._create_optimized_system(
            language_models,
            optimized_prompts,
            optimized_params
        )

        return optimized_system

    def _fine_tune_language_model(self, language, trainset, valset):
        """Fine-tune model for specific language."""

        # Create language-specific dataset
        lang_dataset = prepare_language_dataset(trainset, language)

        # Configure fine-tuning
        config = FineTuningConfig(
            model_name=get_base_model_for_language(language),
            num_epochs=5,
            learning_rate=2e-5,
            batch_size=8,
            language_specific_tokens=get_language_tokens(language)
        )

        # Fine-tune
        fine_tuned_model = fine_tune_language_model(
            lang_dataset,
            config
        )

        # Evaluate
        val_score = evaluate_code_generation(
            fine_tuned_model,
            valset,
            language
        )

        print(f"  {language} validation score: {val_score:.4f}")

        return fine_tuned_model

    def _optimize_prompts_jointly(self, trainsets, valsets, shared_knowledge):
        """Optimize prompts jointly across all languages."""

        # Define joint search space
        joint_search_space = {
            "instruction_template": {
                "type": "categorical",
                "values": [
                    "Generate {language} code for: {requirements}",
                    "Write {language} code that satisfies: {requirements}",
                    "Implement in {language}: {requirements}",
                    "Create a {language} solution for: {requirements}"
                ]
            },
            "include_examples": {"type": "categorical", "values": [True, False]},
            "example_complexity": {
                "type": "categorical",
                "values": ["simple", "medium", "complex"]
            },
            "style_guidance": {
                "type": "categorical",
                "values": ["clean_code", "optimized", "readable", "idiomatic"]
            },
            "constraint_inclusion": {
                "type": "categorical",
                "values": ["none", "performance", "memory", "security"]
            }
        }

        # Multi-objective evaluation function
        def joint_evaluation(prompt_config):
            total_score = 0
            language_scores = {}

            for language in self.system.languages:
                # Create system with prompt config
                system = self._create_system_with_prompt_config(
                    prompt_config,
                    language,
                    shared_knowledge[language]
                )

                # Evaluate on language-specific validation set
                score = evaluate_code_generation(
                    system,
                    valsets[language],
                    language
                )

                language_scores[language] = score
                total_score += score

            # Penalize if performance varies too much between languages
            score_variance = np.var(list(language_scores.values()))
            fairness_penalty = score_variance * 0.1

            avg_score = total_score / len(self.system.languages)
            final_score = avg_score - fairness_penalty

            return final_score, language_scores

        # Run Bayesian optimization
        optimizer = BayesianPromptOptimizer(
            task_signature=None,  # Custom evaluation
            trainset=None,
            valset=None,
            metric_fn=lambda x, y: joint_evaluation(y)[0],
            search_space=joint_search_space,
            max_iterations=100
        )

        # Run optimization with joint evaluation
        best_config, best_score = optimizer.optimize()

        # Create language-specific prompts from best config
        optimized_prompts = {}
        for language in self.system.languages:
            optimized_prompts[language] = adapt_prompt_to_language(
                best_config,
                language,
                shared_knowledge[language]
            )

        return optimized_prompts

# Run the optimization
def optimize_multi_language_code_system():
    """Complete optimization for multi-language code generation."""

    print("=== Multi-Language Code Generation Optimization ===\n")

    # 1. Load data for multiple languages
    languages = ["python", "javascript", "java", "cpp"]
    multi_lang_trainset = {}
    multi_lang_valset = {}

    for lang in languages:
        print(f"Loading {lang} datasets...")
        multi_lang_trainset[lang] = load_code_dataset(lang, split="train")
        multi_lang_valset[lang] = load_code_dataset(lang, split="val")

    # 2. Initialize system
    print("\nInitializing multi-language code generator...")
    system = MultiLanguageCodeGenerator(languages)

    # 3. Create joint optimizer
    print("Setting up joint optimizer...")
    optimizer = JointCodeOptimizer(system)

    # 4. Configure optimization
    optimization_config = {
        "fine_tuning": {
            "epochs_per_language": 5,
            "shared_layers": True,
            "language_adapters": True
        },
        "prompt_optimization": {
            "method": "bayesian",
            "iterations": 100,
            "cross_language_transfer": True
        },
        "parameter_optimization": {
            "method": "joint_gradient",
            "learning_rate": 1e-4,
            "regularization": 0.01
        }
    }

    # 5. Run optimization
    print("\nRunning joint optimization...")
    optimized_system = optimizer.optimize(
        multi_lang_trainset=multi_lang_trainset,
        multi_lang_valset=multi_lang_valset,
        optimization_config=optimization_config
    )

    # 6. Comprehensive evaluation
    print("\n=== Final Evaluation ===")
    test_results = {}
    for lang in languages:
        testset = load_code_dataset(lang, split="test")
        results = evaluate_code_generator(optimized_system, testset, lang)
        test_results[lang] = results

        print(f"\n{lang.upper()} Results:")
        print(f"  Accuracy: {results['accuracy']:.4f}")
        print(f"  Code Quality: {results['quality']:.4f}")
        print(f"  Efficiency: {results['efficiency']:.4f}")

    # 7. Cross-language analysis
    print("\n=== Cross-Language Analysis ===")
    avg_accuracy = np.mean([r['accuracy'] for r in test_results.values()])
    accuracy_std = np.std([r['accuracy'] for r in test_results.values()])

    print(f"Average accuracy: {avg_accuracy:.4f}")
    print(f"Accuracy variance: {accuracy_std:.4f}")

    return optimized_system, test_results
</code></pre>
<h2 id="example-3-adaptive-customer-support-chatbot"><a class="header" href="#example-3-adaptive-customer-support-chatbot">Example 3: Adaptive Customer Support Chatbot</a></h2>
<h3 id="problem-setup-2"><a class="header" href="#problem-setup-2">Problem Setup</a></h3>
<p>Optimizing a customer support chatbot that:</p>
<ul>
<li>Handles multiple support domains</li>
<li>Adapts to user preferences</li>
<li>Maintains consistent brand voice</li>
<li>Escalates complex issues appropriately</li>
</ul>
<h3 id="implementation-with-copa-and-adaptive-optimization"><a class="header" href="#implementation-with-copa-and-adaptive-optimization">Implementation with COPA and Adaptive Optimization</a></h3>
<pre><code class="language-python">class AdaptiveSupportChatbot(dspy.Module):
    """Adaptive customer support chatbot with dynamic optimization."""

    def __init__(self, domains: List[str], brand_guidelines: Dict):
        super().__init__()
        self.domains = domains
        self.brand_guidelines = brand_guidelines

        # Domain-specific modules
        self.domain_classifiers = {
            domain: dspy.Predict(ClassifyIntentSignature())
            for domain in domains
        }

        self.response_generators = {
            domain: dspy.ChainOfThought(GenerateResponseSignature())
            for domain in domains
        }

        # Adaptive components
        self.user_profiler = UserProfileAnalyzer()
        self.emotion_detector = EmotionDetector()
        self.escalation_decider = EscalationDecider()

        # Learnable components
        self.adaptive_prompts = AdaptivePromptManager(domains)
        self.response_templates = LearnableResponseTemplates()

        # Optimization state
        self.performance_tracker = PerformanceTracker()
        self.copa_optimizer = None  # Will be initialized

    def forward(
        self,
        message: str,
        user_id: str,
        conversation_history: List[Dict] = None
    ) -&gt; dspy.Prediction:
        """Generate adaptive response to user message."""

        # Analyze user and context
        user_profile = self.user_profiler.get_profile(user_id)
        emotion = self.emotion_detector.detect(message)

        # Classify intent and domain
        intent = self._classify_intent(message, conversation_history)
        domain = self._determine_domain(message, intent)

        # Get adaptive prompt
        prompt = self.adaptive_prompts.get_prompt(
            domain=domain,
            user_profile=user_profile,
            emotion=emotion,
            brand_guidelines=self.brand_guidelines
        )

        # Generate response
        generator = self.response_generators[domain]
        initial_response = generator(
            message=message,
            prompt=prompt,
            user_preferences=user_profile.preferences,
            conversation_context=conversation_history
        )

        # Check for escalation
        should_escalate = self.escalation_decider.should_escalate(
            message,
            initial_response.response,
            user_profile,
            emotion
        )

        if should_escalate:
            response = self._generate_escalation_response(
                message,
                user_profile,
                initial_response
            )
            escalation_level = "human"
        else:
            response = self._adapt_response(
                initial_response.response,
                user_profile,
                emotion
            )
            escalation_level = "none"

        # Track for optimization
        self.performance_tracker.track_interaction(
            user_id=user_id,
            message=message,
            response=response,
            domain=domain,
            emotion=emotion
        )

        return dspy.Prediction(
            response=response,
            domain=domain,
            emotion=emotion,
            escalation=escalation_level,
            user_satisfaction_predict=self._predict_satisfaction(
                response,
                user_profile
            )
        )

class SupportChatbotOptimizer:
    """Optimizer for adaptive support chatbot using COPA."""

    def __init__(self, chatbot: AdaptiveSupportChatbot):
        self.chatbot = chatbot
        self.copa_optimizer = None
        self.adaptive_strategies = {}

    def optimize(
        self,
        conversation_logs: List[Dict],
        user_feedback: List[Dict],
        optimization_duration: int = 7  # days
    ):
        """Execute continuous COPA-based optimization."""

        print("=== Adaptive Support Chatbot Optimization ===\n")

        # Initialize COPA optimizer
        self.copa_optimizer = COPAOptimizer(
            compilation_optimizer=BootstrapFewShot(),
            prompt_optimizer=MIPRO(),
            max_iterations=10,
            transfer_strategy="knowledge_distillation"
        )

        # Create optimization schedule
        optimization_schedule = self._create_optimization_schedule(optimization_duration)

        # Run optimization loop
        for day in range(optimization_duration):
            print(f"\nDay {day + 1} Optimization:")

            # Collect daily data
            daily_logs = self._filter_logs_by_day(conversation_logs, day)
            daily_feedback = self._filter_feedback_by_day(user_feedback, day)

            # Analyze performance
            performance_report = self._analyze_daily_performance(
                daily_logs,
                daily_feedback
            )

            # Determine optimization focus
            focus_areas = self._determine_optimization_focus(performance_report)

            # Execute COPA optimization
            for focus in focus_areas:
                print(f"  Optimizing {focus}...")
                self._execute_copa_optimization(
                    focus,
                    daily_logs,
                    daily_feedback
                )

            # Update adaptive strategies
            self._update_adaptive_strategies(performance_report)

            # Generate daily report
            self._generate_daily_report(day, performance_report)

        return self._generate_optimization_report()

    def _execute_copa_optimization(self, focus, logs, feedback):
        """Execute COPA optimization for specific focus area."""

        if focus == "domain_accuracy":
            self._optimize_domain_responses(logs, feedback)
        elif focus == "user_satisfaction":
            self._optimize_user_adaptation(logs, feedback)
        elif focus == "escalation_accuracy":
            self._optimize_escalation_decisions(logs, feedback)
        elif focus == "brand_consistency":
            self._optimize_brand_voice(logs, feedback)

    def _optimize_domain_responses(self, logs, feedback):
        """Optimize responses for specific domains using COPA."""

        # Group by domain
        domain_data = {}
        for domain in self.chatbot.domains:
            domain_logs = [log for log in logs if log.get("domain") == domain]
            domain_feedback = [
                fb for fb in feedback
                if any(log["id"] == fb["log_id"] for log in domain_logs)
            ]
            domain_data[domain] = {
                "logs": domain_logs,
                "feedback": domain_feedback
            }

        # Optimize each domain
        for domain, data in domain_data.items():
            if len(data["logs"]) &gt; 10:  # Minimum data threshold

                # Prepare training data
                train_examples = self._prepare_training_examples(
                    data["logs"],
                    data["feedback"]
                )

                # Create domain-specific program
                domain_program = self.chatbot.response_generators[domain]

                # Apply COPA optimization
                optimized_program = self.copa_optimizer.optimize(
                    program=domain_program,
                    trainset=train_examples,
                    valset=self._get_domain_valset(domain)
                )

                # Update chatbot
                self.chatbot.response_generators[domain] = optimized_program

    def _optimize_user_adaptation(self, logs, feedback):
        """Optimize user adaptation strategies."""

        # Analyze user segments
        user_segments = self._segment_users(logs, feedback)

        for segment, segment_data in user_segments.items():
            if len(segment_data) &gt; 5:
                # Optimize prompts for segment
                optimized_prompts = self._optimize_segment_prompts(
                    segment,
                    segment_data
                )

                # Update adaptive prompts
                self.chatbot.adaptive_prompts.update_segment_prompts(
                    segment,
                    optimized_prompts
                )

# Run the optimization
def optimize_support_chatbot():
    """Complete optimization pipeline for support chatbot."""

    print("=== Customer Support Chatbot Optimization ===\n")

    # 1. Load conversation data
    print("Loading conversation logs and feedback...")
    conversation_logs = load_conversation_logs(days=30)
    user_feedback = load_user_feedback(days=30)

    # 2. Initialize chatbot
    print("\nInitializing adaptive support chatbot...")
    domains = ["technical", "billing", "account", "general"]
    brand_guidelines = load_brand_guidelines()
    chatbot = AdaptiveSupportChatbot(domains, brand_guidelines)

    # 3. Create optimizer
    print("Setting up COPA optimizer...")
    optimizer = SupportChatbotOptimizer(chatbot)

    # 4. Run optimization
    print("\nRunning continuous optimization...")
    optimization_report = optimizer.optimize(
        conversation_logs=conversation_logs,
        user_feedback=user_feedback,
        optimization_duration=7
    )

    # 5. Evaluate optimized chatbot
    print("\n=== Final Evaluation ===")
    test_results = evaluate_chatbot_performance(chatbot)

    print("Performance Metrics:")
    for metric, value in test_results.items():
        print(f"  {metric}: {value:.4f}")

    # 6. Simulate real-time adaptation
    print("\n=== Testing Real-time Adaptation ===")
    adaptation_demo = demonstrate_adaptation(chatbot)

    return chatbot, optimization_report, test_results
</code></pre>
<h2 id="implementation-best-practices"><a class="header" href="#implementation-best-practices">Implementation Best Practices</a></h2>
<h3 id="optimization-pipeline-checklist"><a class="header" href="#optimization-pipeline-checklist">Optimization Pipeline Checklist</a></h3>
<pre><code class="language-python">class OptimizationChecklist:
    """Checklist for implementing optimization in DSPy systems."""

    @staticmethod
    def pre_optimization_checks(system, data):
        """Checks before starting optimization."""
        checks = {
            "data_quality": validate_data_quality(data),
            "system_functionality": test_system_functionality(system),
            "baseline_performance": measure_baseline_performance(system, data),
            "resource_availability": check_compute_resources(),
            "optimization_goals": define_clear_objectives()
        }

        return all(checks.values()), checks

    @staticmethod
    def during_optimization_monitoring(optimizer):
        """Monitoring during optimization."""
        monitoring_metrics = {
            "convergence": check_convergence(optimizer.history),
            "resource_usage": monitor_resource_usage(),
            "gradient_health": check_gradient_norms(optimizer),
            "data_drift": detect_data_drift(),
            "overfitting": monitor_validation_gap()
        }

        return monitoring_metrics

    @staticmethod
    def post_optimization_validation(optimized_system, test_data):
        """Validation after optimization."""
        validation_results = {
            "performance_improvement": measure_improvement(optimized_system, test_data),
            "generalization": test_generalization(optimized_system),
            "robustness": test_robustness(optimized_system),
            "efficiency": measure_efficiency(optimized_system),
            "production_readiness": check_production_readiness(optimized_system)
        }

        return validation_results
</code></pre>
<h3 id="common-patterns-and-anti-patterns"><a class="header" href="#common-patterns-and-anti-patterns">Common Patterns and Anti-Patterns</a></h3>
<pre><code class="language-python"># GOOD: Modular optimization
class ModularOptimizer:
    """Example of good modular design."""

    def __init__(self):
        self.components = {
            "preprocessor": DataPreprocessor(),
            "optimizer": CoreOptimizer(),
            "validator": ResultValidator(),
            "monitor": OptimizationMonitor()
        }

    def optimize(self, system, data):
        # Clear separation of concerns
        processed_data = self.components["preprocessor"].process(data)
        optimized_system = self.components["optimizer"].optimize(system, processed_data)
        validation_results = self.components["validator"].validate(optimized_system)
        self.components["monitor"].track_optimization(validation_results)

        return optimized_system

# BAD: Monolithic optimization (anti-pattern)
class MonolithicOptimizer:
    """Example of anti-pattern to avoid."""

    def optimize(self, system, data):
        # Everything mixed together - hard to maintain
        # Data processing
        processed = []
        for item in data:
            # Complex inline processing...
            processed.append(item)

        # Optimization
        for i in range(100):
            # Complex optimization logic mixed with monitoring...
            # Validation logic mixed in...
            pass

        # Everything returns together - no clear separation
        return system, processed, metrics, logs
</code></pre>
<h2 id="production-deployment-guide"><a class="header" href="#production-deployment-guide">Production Deployment Guide</a></h2>
<h3 id="ab-testing-framework"><a class="header" href="#ab-testing-framework">A/B Testing Framework</a></h3>
<pre><code class="language-python">class ABTestManager:
    """Manager for A/B testing optimized systems."""

    def __init__(self):
        self.active_tests = {}
        self.metrics_collector = MetricsCollector()

    def create_test(
        self,
        control_system,
        variant_system,
        traffic_split=0.1,
        test_duration_days=7
    ):
        """Create A/B test between systems."""

        test_id = generate_test_id()

        self.active_tests[test_id] = {
            "control": control_system,
            "variant": variant_system,
            "traffic_split": traffic_split,
            "start_time": datetime.now(),
            "duration_days": test_duration_days,
            "metrics": {
                "control": [],
                "variant": []
            }
        }

        return test_id

    def route_request(self, request, test_id):
        """Route request to appropriate system variant."""
        test = self.active_tests[test_id]

        if random.random() &lt; test["traffic_split"]:
            # Route to variant
            response = test["variant"].process(request)
            group = "variant"
        else:
            # Route to control
            response = test["control"].process(request)
            group = "control"

        # Collect metrics
        metrics = self.metrics_collector.collect(request, response)
        test["metrics"][group].append(metrics)

        return response, group

    def analyze_test(self, test_id):
        """Analyze A/B test results."""
        test = self.active_tests[test_id]

        control_metrics = test["metrics"]["control"]
        variant_metrics = test["metrics"]["variant"]

        # Statistical analysis
        significance = calculate_statistical_significance(
            control_metrics,
            variant_metrics
        )

        improvement = calculate_improvement(
            control_metrics,
            variant_metrics
        )

        return {
            "significant": significance["p_value"] &lt; 0.05,
            "improvement": improvement,
            "confidence_interval": significance["confidence_interval"]
        }
</code></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>These comprehensive examples demonstrate how to apply advanced optimization techniques to real-world DSPy applications. The key takeaways include:</p>
<ol>
<li><strong>Modular Design</strong>: Build systems with clear separation of concerns</li>
<li><strong>Multi-Objective Optimization</strong>: Balance multiple metrics simultaneously</li>
<li><strong>Adaptive Optimization</strong>: Continuously improve based on real-world feedback</li>
<li><strong>Production Readiness</strong>: Include monitoring, A/B testing, and gradual deployment</li>
<li><strong>Domain-Specific Adaptation</strong>: Tailor optimization strategies to specific domains</li>
</ol>
<p>The examples show that successful optimization requires:</p>
<ul>
<li>Understanding the problem domain</li>
<li>Choosing appropriate optimization techniques</li>
<li>Careful implementation and monitoring</li>
<li>Iterative improvement based on results</li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>With these comprehensive examples, you now have the tools to optimize complex DSPy systems for production use. The next chapter will cover deployment strategies and scaling considerations for optimized DSPy applications.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../05-optimizers/12-bayesian-optimization.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="../05-optimizers/06-choosing-optimizers.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../05-optimizers/12-bayesian-optimization.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="../05-optimizers/06-choosing-optimizers.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>






        <script src="../clipboard-1626706a.min.js"></script>
        <script src="../highlight-abc7f01d.js"></script>
        <script src="../book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
