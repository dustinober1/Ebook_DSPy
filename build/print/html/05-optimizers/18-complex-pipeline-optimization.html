<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Complex Pipeline Optimization - DSPy: A Practical Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="The most comprehensive DSPy guide with complete coverage of 9 research papers, advanced optimization techniques, and production-ready applications">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon-de23e50b.svg">
        <link rel="shortcut icon" href="../favicon-8114d1fc.png">
        <link rel="stylesheet" href="../css/variables-8adf115d.css">
        <link rel="stylesheet" href="../css/general-2459343d.css">
        <link rel="stylesheet" href="../css/chrome-ae938929.css">
        <link rel="stylesheet" href="../css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="../highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="../tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="../ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../assets/print-only-ef201963.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc-4ea68664.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">DSPy: A Practical Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="optimization-strategies-for-complex-pipelines"><a class="header" href="#optimization-strategies-for-complex-pipelines">Optimization Strategies for Complex Pipelines</a></h1>
<h2 id="learning-objectives"><a class="header" href="#learning-objectives">Learning Objectives</a></h2>
<p>By the end of this section, you will be able to:</p>
<ul>
<li>Design hierarchical optimization strategies for multi-stage pipelines</li>
<li>Implement stage-wise tuning with coordination mechanisms</li>
<li>Apply resource-aware optimization under constraints</li>
<li>Handle optimization of branching and conditional pipelines</li>
<li>Evaluate and compare different pipeline optimization approaches</li>
</ul>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Optimizing complex multi-stage pipelines presents unique challenges that go beyond single-stage or simple sequential optimization. Complex pipelines may include:</p>
<ul>
<li><strong>Hierarchical dependencies</strong>: Stages that depend on outputs from multiple previous stages</li>
<li><strong>Resource constraints</strong>: Different stages requiring different computational resources</li>
<li><strong>Conditional execution</strong>: Paths that change based on intermediate results</li>
<li><strong>Feedback loops</strong>: Iterative refinement and self-correction mechanisms</li>
</ul>
<p>This section explores advanced optimization strategies specifically designed for such complex scenarios.</p>
<h2 id="hierarchical-optimization"><a class="header" href="#hierarchical-optimization">Hierarchical Optimization</a></h2>
<h3 id="multi-level-optimization-framework"><a class="header" href="#multi-level-optimization-framework">Multi-level Optimization Framework</a></h3>
<p>Complex pipelines benefit from hierarchical optimization where we optimize at different levels of abstraction:</p>
<pre><code>Level 3: Global Pipeline Optimization
├── Level 2: Sub-pipeline Optimization
│   ├── Level 1: Stage-wise Optimization
│   │   ├── Instructions
│   │   └── Demonstrations
│   └── Inter-stage Coordination
└── Resource Allocation
</code></pre>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<pre><code class="language-python">import dspy
from typing import Dict, List, Any, Optional
import numpy as np
from dataclasses import dataclass

@dataclass
class OptimizationLevel:
    """Configuration for optimization level."""
    name: str
    budget: float  # Fraction of total budget
    priority: int  # Optimization priority
    dependencies: List[str]  # Dependent levels

class HierarchicalOptimizer:
    """Hierarchical optimizer for complex pipelines."""

    def __init__(
        self,
        pipeline,
        optimization_levels: List[OptimizationLevel],
        total_budget: float = 1.0
    ):
        self.pipeline = pipeline
        self.levels = optimization_levels
        self.total_budget = total_budget
        self.optimization_state = {}

    def optimize(self, trainset, validation_set):
        """Execute hierarchical optimization."""

        # Initialize optimization state
        for level in self.levels:
            self.optimization_state[level.name] = {
                'optimized': False,
                'score': 0.0,
                'parameters': None
            }

        # Optimize in priority order
        sorted_levels = sorted(self.levels, key=lambda x: x.priority)

        for level in sorted_levels:
            # Check dependencies
            if not self._check_dependencies(level):
                print(f"Skipping {level.name}: Dependencies not met")
                continue

            print(f"Optimizing {level.name}...")

            # Allocate budget
            allocated_budget = level.budget * self.total_budget

            # Optimize at this level
            result = self._optimize_level(
                level.name,
                trainset,
                validation_set,
                allocated_budget
            )

            # Update state
            self.optimization_state[level.name] = result

        return self.optimization_state

    def _check_dependencies(self, level: OptimizationLevel) -&gt; bool:
        """Check if level dependencies are satisfied."""

        for dep in level.dependencies:
            if not self.optimization_state[dep]['optimized']:
                return False

        return True

    def _optimize_level(self, level_name, trainset, val_set, budget):
        """Optimize at specific level."""

        if level_name == 'stage_wise':
            return self._optimize_stage_wise(trainset, val_set, budget)
        elif level_name == 'sub_pipeline':
            return self._optimize_sub_pipelines(trainset, val_set, budget)
        elif level_name == 'global':
            return self._optimize_global(trainset, val_set, budget)
        elif level_name == 'resource_allocation':
            return self._optimize_resource_allocation(trainset, val_set, budget)
        else:
            raise ValueError(f"Unknown optimization level: {level_name}")

    def _optimize_stage_wise(self, trainset, val_set, budget):
        """Optimize individual stages."""

        stage_results = {}
        total_score = 0.0

        # Distribute budget among stages
        stage_budget = budget / len(self.pipeline.stages)

        for stage_name, stage in self.pipeline.stages.items():
            print(f"  Optimizing stage: {stage_name}")

            # Get stage-specific data
            stage_data = self._extract_stage_data(stage_name, trainset)
            stage_val = self._extract_stage_data(stage_name, val_set)

            # Optimize stage
            optimizer = self._create_stage_optimizer(stage)
            result = optimizer.compile(stage, trainset=stage_data)

            # Evaluate
            score = self._evaluate_stage(stage, stage_val)
            stage_results[stage_name] = {
                'optimizer': optimizer,
                'score': score,
                'parameters': result
            }
            total_score += score

        return {
            'optimized': True,
            'score': total_score / len(self.pipeline.stages),
            'parameters': stage_results
        }
</code></pre>
<h3 id="adaptive-budget-allocation"><a class="header" href="#adaptive-budget-allocation">Adaptive Budget Allocation</a></h3>
<p>Dynamically allocate optimization budget based on stage importance and potential.</p>
<pre><code class="language-python">class AdaptiveBudgetAllocator:
    """Adaptive allocation of optimization budget."""

    def __init__(self, importance_weights=None):
        self.importance_weights = importance_weights or {}

    def allocate_budget(
        self,
        pipeline,
        total_budget,
        historical_performance=None
    ):
        """Allocate budget based on multiple factors."""

        # Analyze stage characteristics
        stage_scores = self._analyze_stages(pipeline)

        # Adjust based on historical performance
        if historical_performance:
            stage_scores = self._adjust_with_history(
                stage_scores, historical_performance
            )

        # Normalize and allocate
        total_score = sum(stage_scores.values())
        allocations = {}

        for stage_name, score in stage_scores.items():
            weight = self.importance_weights.get(stage_name, 1.0)
            adjusted_score = score * weight
            allocation = (adjusted_score / total_score) * total_budget
            allocations[stage_name] = allocation

        return allocations

    def _analyze_stages(self, pipeline):
        """Analyze stages for budget allocation."""

        scores = {}

        for stage_name, stage in pipeline.stages.items():
            score = 0.0

            # Factor 1: Complexity (more complex stages get more budget)
            complexity = self._measure_complexity(stage)
            score += complexity * 0.3

            # Factor 2: Position (earlier stages often more critical)
            position = list(pipeline.stages.keys()).index(stage_name)
            position_score = 1.0 / (position + 1)
            score += position_score * 0.2

            # Factor 3: Error rate (stages with higher errors need more work)
            error_rate = self._estimate_error_rate(stage)
            score += error_rate * 0.3

            # Factor 4: Performance impact
            impact = self._estimate_performance_impact(stage)
            score += impact * 0.2

            scores[stage_name] = score

        return scores

    def _measure_complexity(self, stage):
        """Measure stage complexity."""

        # Simple heuristic based on stage type and parameters
        complexity = 1.0

        if hasattr(stage, 'instruction') and stage.instruction:
            complexity += len(stage.instruction.split()) / 100

        if hasattr(stage, 'demonstrations') and stage.demonstrations:
            complexity += len(stage.demonstrations) * 0.1

        if hasattr(stage, 'signature'):
            # Count fields in signature
            num_fields = len(stage.signature.fields)
            complexity += num_fields * 0.1

        return complexity
</code></pre>
<h2 id="stage-wise-tuning-with-coordination"><a class="header" href="#stage-wise-tuning-with-coordination">Stage-wise Tuning with Coordination</a></h2>
<h3 id="coordinated-stage-optimization"><a class="header" href="#coordinated-stage-optimization">Coordinated Stage Optimization</a></h3>
<p>Optimize stages while considering their interactions.</p>
<pre><code class="language-python">class CoordinatedStageOptimizer:
    """Optimizer that coordinates stage optimization."""

    def __init__(self, coordination_strategy='iterative'):
        self.coordination_strategy = coordination_strategy
        self.stage_interactions = {}

    def optimize_pipeline(
        self,
        pipeline,
        trainset,
        val_set,
        num_rounds=3
    ):
        """Optimize all stages with coordination."""

        optimization_history = []

        for round_num in range(num_rounds):
            print(f"\nOptimization round {round_num + 1}")

            round_results = {}

            # Get current pipeline state
            current_state = self._get_pipeline_state(pipeline)

            # Optimize each stage
            for stage_name, stage in pipeline.stages.items():
                # Get dependent stage information
                dependencies = self._get_stage_dependencies(stage_name, pipeline)

                # Optimize with coordination
                result = self._optimize_stage_with_coordination(
                    stage_name,
                    stage,
                    dependencies,
                    current_state,
                    trainset,
                    val_set
                )

                round_results[stage_name] = result

            # Update stage interactions
            self._update_interactions(round_results, pipeline)

            # Evaluate overall pipeline
            pipeline_score = self._evaluate_pipeline(pipeline, val_set)
            optimization_history.append({
                'round': round_num,
                'stage_results': round_results,
                'pipeline_score': pipeline_score
            })

            # Check for convergence
            if self._has_converged(optimization_history):
                print("Converged - stopping optimization")
                break

        return optimization_history

    def _optimize_stage_with_coordination(
        self,
        stage_name,
        stage,
        dependencies,
        current_state,
        trainset,
        val_set
    ):
        """Optimize a single stage considering dependencies."""

        # Create coordination context
        context = self._create_coordination_context(
            stage_name,
            dependencies,
            current_state
        )

        # Prepare stage-specific optimizer
        optimizer = self._create_coordinated_optimizer(context)

        # Extract stage data
        stage_data = self._extract_stage_data_with_context(
            stage_name,
            trainset,
            context
        )

        # Optimize
        result = optimizer.compile(stage, trainset=stage_data)

        # Validate coordination constraints
        if not self._validate_coordination_constraints(
            stage_name,
            result,
            context
        ):
            # Apply coordination adjustments
            result = self._apply_coordination_adjustments(
                result,
                context
            )

        return {
            'stage_name': stage_name,
            'result': result,
            'context': context,
            'score': self._evaluate_stage_with_context(
                stage, val_set, context
            )
        }

    def _create_coordination_context(
        self,
        stage_name,
        dependencies,
        current_state
    ):
        """Create context for coordinated optimization."""

        context = {
            'stage_name': stage_name,
            'dependencies': dependencies,
            'current_state': current_state,
            'interaction_history': self.stage_interactions.get(stage_name, {})
        }

        # Add constraints from dependencies
        for dep_name, dep_info in dependencies.items():
            if dep_name in current_state:
                context[f'{dep_name}_constraints'] = self._derive_constraints(
                    dep_info,
                    current_state[dep_name]
                )

        return context
</code></pre>
<h3 id="constraint-based-coordination"><a class="header" href="#constraint-based-coordination">Constraint-based Coordination</a></h3>
<p>Enforce constraints between stages during optimization.</p>
<pre><code class="language-python">class ConstraintCoordinator:
    """Manage constraints between stages."""

    def __init__(self):
        self.constraints = []
        self.constraint_handlers = {
            'format_compatibility': self._handle_format_constraint,
            'performance_threshold': self._handle_performance_constraint,
            'resource_limit': self._handle_resource_constraint,
            'semantic_consistency': self._handle_semantic_constraint
        }

    def add_constraint(self, constraint_type, stages, constraint_spec):
        """Add a coordination constraint."""

        constraint = {
            'type': constraint_type,
            'stages': stages,
            'spec': constraint_spec
        }
        self.constraints.append(constraint)

    def validate_and_adjust(
        self,
        stage_name,
        stage_result,
        all_results
    ):
        """Validate and adjust stage results based on constraints."""

        relevant_constraints = [
            c for c in self.constraints
            if stage_name in c['stages']
        ]

        adjusted_result = stage_result

        for constraint in relevant_constraints:
            handler = self.constraint_handlers.get(constraint['type'])
            if handler:
                adjusted_result = handler(
                    stage_name,
                    adjusted_result,
                    constraint,
                    all_results
                )

        return adjusted_result

    def _handle_format_constraint(
        self,
        stage_name,
        stage_result,
        constraint,
        all_results
    ):
        """Handle format compatibility constraints."""

        # Ensure output format matches input format of next stage
        next_stages = [s for s in constraint['stages'] if s != stage_name]

        for next_stage in next_stages:
            if next_stage in all_results:
                # Get expected format
                expected_format = all_results[next_stage].get('input_format')

                # Adjust current result if needed
                if not self._is_format_compatible(
                    stage_result, expected_format
                ):
                    stage_result = self._convert_format(
                        stage_result, expected_format
                    )

        return stage_result

    def _is_format_compatible(self, result, expected_format):
        """Check if result format matches expected."""

        # Simplified format checking
        if expected_format == 'json' and isinstance(result, dict):
            return True
        elif expected_format == 'string' and isinstance(result, str):
            return True
        else:
            return False

    def _convert_format(self, result, target_format):
        """Convert result to target format."""

        if target_format == 'json' and not isinstance(result, dict):
            # Convert string to JSON-like structure
            try:
                import json
                if isinstance(result, str):
                    return json.loads(result)
            except:
                # Fallback to simple structure
                return {'content': result}

        elif target_format == 'string' and not isinstance(result, str):
            # Convert to string
            if isinstance(result, dict):
                return json.dumps(result, indent=2)
            else:
                return str(result)

        return result
</code></pre>
<h2 id="resource-aware-optimization"><a class="header" href="#resource-aware-optimization">Resource-aware Optimization</a></h2>
<h3 id="multi-resource-optimization"><a class="header" href="#multi-resource-optimization">Multi-resource Optimization</a></h3>
<p>Optimize considering multiple resource dimensions (compute, memory, latency).</p>
<pre><code class="language-python">class MultiResourceOptimizer:
    """Optimizer considering multiple resource constraints."""

    def __init__(self, resource_limits):
        self.resource_limits = resource_limits
        self.resource_metrics = {
            'compute': self._measure_compute,
            'memory': self._measure_memory,
            'latency': self._measure_latency,
            'cost': self._estimate_cost
        }

    def optimize_with_constraints(
        self,
        pipeline,
        trainset,
        val_set,
        objective_weights=None
    ):
        """Optimize under resource constraints."""

        objective_weights = objective_weights or {
            'performance': 0.5,
            'compute': 0.2,
            'memory': 0.15,
            'latency': 0.15
        }

        best_configuration = None
        best_score = -float('inf')

        # Generate candidate configurations
        candidates = self._generate_candidates(pipeline)

        for candidate in candidates:
            # Apply configuration
            self._apply_configuration(pipeline, candidate)

            # Measure resources
            resource_usage = self._measure_resources(pipeline, val_set)

            # Check constraints
            if not self._check_constraints(resource_usage):
                continue

            # Evaluate performance
            performance = self._evaluate_pipeline(pipeline, val_set)

            # Compute overall score
            score = self._compute_objective(
                performance,
                resource_usage,
                objective_weights
            )

            if score &gt; best_score:
                best_score = score
                best_configuration = candidate

        # Apply best configuration
        if best_configuration:
            self._apply_configuration(pipeline, best_configuration)

        return {
            'configuration': best_configuration,
            'score': best_score,
            'resource_usage': self._measure_resources(pipeline, val_set)
        }

    def _generate_candidates(self, pipeline):
        """Generate optimization candidates."""

        candidates = []

        # Different optimization strategies
        strategies = [
            {'name': 'quality_focused', 'emphasis': 'performance'},
            {'name': 'speed_focused', 'emphasis': 'latency'},
            {'name': 'balanced', 'emphasis': 'overall'},
            {'name': 'resource_efficient', 'emphasis': 'resource_usage'}
        ]

        # Generate combinations
        for strategy in strategies:
            for stage_name in pipeline.stages:
                # Different configurations per stage
                stage_configs = self._generate_stage_configs(
                    pipeline.stages[stage_name],
                    strategy
                )

                for config in stage_configs:
                    candidate = {
                        'strategy': strategy,
                        'stages': {stage_name: config}
                    }
                    candidates.append(candidate)

        return candidates

    def _generate_stage_configs(self, stage, strategy):
        """Generate configurations for a specific stage."""

        configs = []

        if strategy['emphasis'] == 'performance':
            # Focus on quality: more demonstrations, detailed instructions
            configs.append({
                'num_demonstrations': min(8, getattr(stage, 'max_demos', 5) * 2),
                'instruction_length': 'long',
                'model_temperature': 0.1
            })

        elif strategy['emphasis'] == 'latency':
            # Focus on speed: fewer examples, concise instructions
            configs.append({
                'num_demonstrations': 2,
                'instruction_length': 'short',
                'model_temperature': 0.5
            })

        elif strategy['emphasis'] == 'resource_usage':
            # Focus on efficiency: balanced approach
            configs.append({
                'num_demonstrations': 4,
                'instruction_length': 'medium',
                'model_temperature': 0.3
            })

        return configs

    def _check_constraints(self, resource_usage):
        """Check if resource usage is within limits."""

        for resource, usage in resource_usage.items():
            if resource in self.resource_limits:
                limit = self.resource_limits[resource]
                if usage &gt; limit:
                    return False

        return True

    def _compute_objective(
        self,
        performance,
        resource_usage,
        weights
    ):
        """Compute multi-objective score."""

        # Normalize performance (0-1)
        norm_performance = min(performance / 100, 1.0)

        # Normalize resource usage (inverse - lower is better)
        norm_resources = {}
        for resource, usage in resource_usage.items():
            if resource in self.resource_limits:
                norm_resources[resource] = 1 - (usage / self.resource_limits[resource])
            else:
                norm_resources[resource] = 1.0

        # Compute weighted score
        score = (
            weights['performance'] * norm_performance +
            weights['compute'] * norm_resources.get('compute', 1.0) +
            weights['memory'] * norm_resources.get('memory', 1.0) +
            weights['latency'] * norm_resources.get('latency', 1.0)
        )

        return score
</code></pre>
<h3 id="dynamic-resource-scaling"><a class="header" href="#dynamic-resource-scaling">Dynamic Resource Scaling</a></h3>
<p>Adjust resource allocation based on runtime conditions.</p>
<pre><code class="language-python">class DynamicResourceScaler:
    """Scale resources dynamically based on conditions."""

    def __init__(self, scaling_rules=None):
        self.scaling_rules = scaling_rules or self._default_rules()
        self.current_allocation = {}
        self.performance_history = []

    def scale_pipeline(
        self,
        pipeline,
        current_load,
        performance_metrics
    ):
        """Scale pipeline based on current conditions."""

        # Analyze current state
        analysis = self._analyze_conditions(current_load, performance_metrics)

        # Apply scaling rules
        new_allocation = self._apply_scaling_rules(analysis)

        # Update pipeline if allocation changed
        if new_allocation != self.current_allocation:
            self._update_pipeline_resources(pipeline, new_allocation)
            self.current_allocation = new_allocation

        return {
            'allocation': new_allocation,
            'analysis': analysis,
            'scaling_applied': new_allocation != self.current_allocation
        }

    def _default_rules(self):
        """Default scaling rules."""

        return [
            {
                'condition': 'high_load',
                'action': 'reduce_demonstrations',
                'parameters': {'factor': 0.5}
            },
            {
                'condition': 'low_accuracy',
                'action': 'increase_demonstrations',
                'parameters': {'factor': 1.5}
            },
            {
                'condition': 'high_latency',
                'action': 'simplify_instructions',
                'parameters': {'target_length': 'short'}
            },
            {
                'condition': 'memory_pressure',
                'action': 'disable_caching',
                'parameters': {}
            }
        ]

    def _analyze_conditions(self, load, metrics):
        """Analyze current conditions."""

        analysis = {}

        # Load conditions
        analysis['load_level'] = self._classify_load(load)
        analysis['load_trend'] = self._compute_load_trend(load)

        # Performance conditions
        analysis['accuracy_trend'] = self._compute_trend(
            metrics.get('accuracy', []), window=5
        )
        analysis['latency_trend'] = self._compute_trend(
            metrics.get('latency', []), window=5
        )

        # Resource conditions
        analysis['memory_usage'] = metrics.get('memory_usage', 0)
        analysis['cpu_usage'] = metrics.get('cpu_usage', 0)

        return analysis

    def _apply_scaling_rules(self, analysis):
        """Apply scaling rules based on analysis."""

        allocation = self.current_allocation.copy()

        for rule in self.scaling_rules:
            if self._rule_matches(rule, analysis):
                allocation = self._apply_rule(
                    rule,
                    allocation,
                    analysis
                )

        return allocation

    def _rule_matches(self, rule, analysis):
        """Check if scaling rule conditions match."""

        condition = rule['condition']

        if condition == 'high_load':
            return analysis['load_level'] == 'high'
        elif condition == 'low_accuracy':
            return analysis['accuracy_trend'] &lt; -0.05
        elif condition == 'high_latency':
            return analysis['latency_trend'] &gt; 0.1
        elif condition == 'memory_pressure':
            return analysis['memory_usage'] &gt; 0.8

        return False

    def _apply_rule(self, rule, allocation, analysis):
        """Apply a specific scaling rule."""

        action = rule['action']
        params = rule['parameters']

        if action == 'reduce_demonstrations':
            factor = params['factor']
            for stage in allocation.get('stages', {}):
                current = allocation['stages'][stage].get('demonstrations', 5)
                allocation['stages'][stage]['demonstrations'] = max(1, int(current * factor))

        elif action == 'increase_demonstrations':
            factor = params['factor']
            for stage in allocation.get('stages', {}):
                current = allocation['stages'][stage].get('demonstrations', 5)
                allocation['stages'][stage]['demonstrations'] = min(10, int(current * factor))

        elif action == 'simplify_instructions':
            target_length = params['target_length']
            for stage in allocation.get('stages', {}):
                allocation['stages'][stage]['instruction_length'] = target_length

        elif action == 'disable_caching':
            allocation['cache_enabled'] = False

        return allocation
</code></pre>
<h2 id="optimization-of-conditional-and-branching-pipelines"><a class="header" href="#optimization-of-conditional-and-branching-pipelines">Optimization of Conditional and Branching Pipelines</a></h2>
<h3 id="branch-aware-optimization"><a class="header" href="#branch-aware-optimization">Branch-aware Optimization</a></h3>
<p>Optimize pipelines with conditional execution paths.</p>
<pre><code class="language-python">class BranchAwareOptimizer:
    """Optimizer for pipelines with conditional branches."""

    def __init__(self):
        self.branch_analyzer = BranchAnalyzer()
        self.path_optimizer = PathOptimizer()

    def optimize_conditional_pipeline(
        self,
        pipeline,
        trainset,
        val_set
    ):
        """Optimize conditional pipeline."""

        # Analyze pipeline structure
        analysis = self.branch_analyzer.analyze(pipeline)

        # Optimize each execution path
        path_optimizations = {}

        for path_info in analysis['execution_paths']:
            path_name = path_info['name']
            path_stages = path_info['stages']

            print(f"Optimizing path: {path_name}")

            # Get data for this path
            path_data = self._filter_data_for_path(
                trainset,
                path_info['condition']
            )

            if path_data:
                # Optimize path
                optimization = self.path_optimizer.optimize_path(
                    pipeline,
                    path_stages,
                    path_data,
                    val_set
                )

                path_optimizations[path_name] = optimization

        # Optimize routing logic
        routing_optimization = self._optimize_routing(
            pipeline,
            analysis['routing_stages'],
            trainset,
            val_set
        )

        # Combine optimizations
        full_optimization = {
            'path_optimizations': path_optimizations,
            'routing_optimization': routing_optimization,
            'analysis': analysis
        }

        return full_optimization

    def _filter_data_for_path(self, dataset, condition):
        """Filter dataset for specific execution path."""

        # This depends on the condition type
        # Simplified implementation
        filtered = []

        for example in dataset:
            # Check if example matches path condition
            if self._matches_condition(example, condition):
                filtered.append(example)

        return filtered

    def _optimize_routing(
        self,
        pipeline,
        routing_stages,
        trainset,
        val_set
    ):
        """Optimize routing/branching decisions."""

        routing_optimizations = {}

        for routing_stage in routing_stages:
            stage_name = routing_stage['name']
            stage_module = pipeline.stages[stage_name]

            # Extract routing decisions
            routing_data = self._extract_routing_data(
                stage_module,
                trainset
            )

            # Optimize routing classifier
            if routing_data:
                optimization = self._optimize_router(
                    stage_module,
                    routing_data,
                    val_set
                )

                routing_optimizations[stage_name] = optimization

        return routing_optimizations

class BranchAnalyzer:
    """Analyze branching structure of pipeline."""

    def analyze(self, pipeline):
        """Analyze pipeline structure."""

        analysis = {
            'execution_paths': [],
            'routing_stages': [],
            'branch_points': []
        }

        # Find routing stages
        for stage_name, stage in pipeline.stages.items():
            if hasattr(stage, 'branches'):
                analysis['routing_stages'].append({
                    'name': stage_name,
                    'branches': stage.branches,
                    'type': type(stage).__name__
                })

        # Find execution paths
        paths = self._find_execution_paths(pipeline)
        analysis['execution_paths'] = paths

        return analysis

    def _find_execution_paths(self, pipeline):
        """Find all possible execution paths."""

        paths = []
        visited = set()

        def dfs(current_stage, current_path, conditions):
            if current_stage in visited:
                return

            visited.add(current_stage)
            current_path.append(current_stage)

            # Check if stage has branches
            stage = pipeline.stages[current_stage]
            if hasattr(stage, 'branches'):
                for branch_name, branch_info in stage.branches.items():
                    # Create new path for branch
                    new_path = current_path.copy()
                    new_conditions = conditions.copy()
                    new_conditions.append({
                        'stage': current_stage,
                        'branch': branch_name,
                        'condition': branch_info.get('condition')
                    })

                    # Continue DFS
                    next_stage = branch_info.get('next_stage')
                    if next_stage:
                        dfs(next_stage, new_path, new_conditions)

                    # Record path
                    paths.append({
                        'name': f"path_{'_'.join(new_path)}",
                        'stages': new_path,
                        'conditions': new_conditions
                    })
            else:
                # Continue to next stage
                # This is simplified - actual implementation depends on pipeline structure
                pass

        # Start from first stage
        if pipeline.stages:
            first_stage = list(pipeline.stages.keys())[0]
            dfs(first_stage, [], [])

        return paths
</code></pre>
<h2 id="evaluation-and-comparison"><a class="header" href="#evaluation-and-comparison">Evaluation and Comparison</a></h2>
<h3 id="multi-dimensional-evaluation"><a class="header" href="#multi-dimensional-evaluation">Multi-dimensional Evaluation</a></h3>
<p>Evaluate optimizations across multiple dimensions.</p>
<pre><code class="language-python">class MultiDimensionalEvaluator:
    """Evaluate optimizations across multiple dimensions."""

    def __init__(self, evaluation_metrics=None):
        self.evaluation_metrics = evaluation_metrics or {
            'performance': ['accuracy', 'f1', 'bleu'],
            'efficiency': ['latency', 'throughput', 'resource_usage'],
            'robustness': ['error_rate', 'consistency', 'graceful_degradation'],
            'scalability': ['performance_vs_load', 'memory_growth']
        }

    def evaluate_optimization(
        self,
        pipeline,
        optimization_result,
        test_sets
    ):
        """Comprehensive evaluation of optimization."""

        evaluation = {
            'optimization_id': optimization_result.get('id'),
            'timestamp': time.time(),
            'results': {}
        }

        for dimension, metrics in self.evaluation_metrics.items():
            dimension_results = {}

            for metric in metrics:
                # Evaluate metric on all test sets
                metric_results = {}
                for test_name, test_set in test_sets.items():
                    value = self._evaluate_metric(
                        pipeline,
                        metric,
                        test_set
                    )
                    metric_results[test_name] = value

                dimension_results[metric] = {
                    'values': metric_results,
                    'average': np.mean(list(metric_results.values())),
                    'std': np.std(list(metric_results.values()))
                }

            evaluation['results'][dimension] = dimension_results

        # Compute overall scores
        evaluation['overall_scores'] = self._compute_overall_scores(
            evaluation['results']
        )

        return evaluation

    def _evaluate_metric(self, pipeline, metric, test_set):
        """Evaluate specific metric on test set."""

        if metric in ['accuracy', 'f1', 'bleu']:
            return self._evaluate_performance_metric(
                pipeline, metric, test_set
            )
        elif metric in ['latency', 'throughput']:
            return self._evaluate_efficiency_metric(
                pipeline, metric, test_set
            )
        elif metric in ['error_rate', 'consistency']:
            return self._evaluate_robustness_metric(
                pipeline, metric, test_set
            )
        else:
            return self._evaluate_default_metric(
                pipeline, metric, test_set
            )

    def compare_optimizations(self, evaluations):
        """Compare multiple optimization evaluations."""

        comparison = {
            'rankings': {},
            'improvements': {},
            'trade_offs': []
        }

        # Rank optimizations by each dimension
        for dimension in self.evaluation_metrics.keys():
            dimension_scores = []

            for eval_id, evaluation in evaluations.items():
                score = np.mean([
                    metric_info['average']
                    for metric_info in evaluation['results'][dimension].values()
                ])
                dimension_scores.append((eval_id, score))

            # Sort by score
            dimension_scores.sort(key=lambda x: x[1], reverse=True)
            comparison['rankings'][dimension] = dimension_scores

        # Compute improvements
        if len(evaluations) &gt; 1:
            baseline = list(evaluations.values())[0]  # First as baseline

            for eval_id, evaluation in evaluations[1:].items():
                improvements = self._compute_improvements(
                    baseline,
                    evaluation
                )
                comparison['improvements'][eval_id] = improvements

        # Identify trade-offs
        comparison['trade_offs'] = self._analyze_trade_offs(
            evaluations
        )

        return comparison

    def _compute_improvements(self, baseline, optimized):
        """Compute improvements relative to baseline."""

        improvements = {}

        for dimension in self.evaluation_metrics.keys():
            dimension_improvement = {}

            for metric in self.evaluation_metrics[dimension]:
                baseline_avg = baseline['results'][dimension][metric]['average']
                optimized_avg = optimized['results'][dimension][metric]['average']

                if baseline_avg != 0:
                    improvement = (optimized_avg - baseline_avg) / baseline_avg
                else:
                    improvement = 0 if optimized_avg == 0 else 1

                dimension_improvement[metric] = {
                    'absolute': optimized_avg - baseline_avg,
                    'relative': improvement,
                    'direction': 'improvement' if improvement &gt; 0 else 'degradation'
                }

            improvements[dimension] = dimension_improvement

        return improvements
</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-optimization-strategy-selection"><a class="header" href="#1-optimization-strategy-selection">1. Optimization Strategy Selection</a></h3>
<ul>
<li><strong>Start Simple</strong>: Begin with stage-wise optimization before complex coordination</li>
<li><strong>Understand Dependencies</strong>: Map out stage interactions before optimization</li>
<li><strong>Consider Resources</strong>: Factor in computational constraints early</li>
<li><strong>Monitor Continuously</strong>: Track performance during and after optimization</li>
<li><strong>Iterate</strong>: Optimization is often an iterative process</li>
</ul>
<h3 id="2-common-pitfalls"><a class="header" href="#2-common-pitfalls">2. Common Pitfalls</a></h3>
<ul>
<li><strong>Over-optimizing</strong>: Diminishing returns after certain point</li>
<li><strong>Ignoring Constraints</strong>: Resource limits can make optimizations impractical</li>
<li><strong>Local Optima</strong>: Getting stuck in suboptimal configurations</li>
<li><strong>Incompatibility</strong>: Optimizations breaking inter-stage compatibility</li>
<li><strong>Validation Leakage</strong>: Using validation data for optimization decisions</li>
</ul>
<h3 id="3-success-metrics"><a class="header" href="#3-success-metrics">3. Success Metrics</a></h3>
<p>Define clear metrics for optimization success:</p>
<ul>
<li>Performance improvement on target task</li>
<li>Resource efficiency gains</li>
<li>Stability across different inputs</li>
<li>Maintainability and interpretability</li>
<li>Deployment readiness</li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Optimization strategies for complex pipelines require sophisticated approaches that account for:</p>
<ul>
<li>Hierarchical structure and interdependencies</li>
<li>Resource constraints and scaling requirements</li>
<li>Conditional execution and branching logic</li>
<li>Multi-dimensional evaluation criteria</li>
</ul>
<p>Key takeaways:</p>
<ol>
<li><strong>Hierarchical Optimization</strong>: Multiple levels from stage-wise to global optimization</li>
<li><strong>Coordination Mechanisms</strong>: Constraints and coordination between stages</li>
<li><strong>Resource Awareness</strong>: Optimization under multiple resource constraints</li>
<li><strong>Conditional Handling</strong>: Special strategies for branching pipelines</li>
<li><strong>Comprehensive Evaluation</strong>: Multi-dimensional assessment of optimizations</li>
</ol>
<p>The final section will explore the interaction effects between instructions and demonstrations, completing our coverage of advanced optimization techniques.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../05-optimizers/17-multistage-architectures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="../05-optimizers/19-instruction-demonstration-interactions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../05-optimizers/17-multistage-architectures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="../05-optimizers/19-instruction-demonstration-interactions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>






        <script src="../clipboard-1626706a.min.js"></script>
        <script src="../highlight-abc7f01d.js"></script>
        <script src="../book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
