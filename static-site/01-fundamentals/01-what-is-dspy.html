<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1. What is DSPy? - DSPy: A Practical Guide</title>
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
</head>
<body>
    <div id="app">
        
    <nav class="page-sidebar">
      
    <div class="logo">
      <h1>DSPy</h1>
      <div class="subtitle">A Practical Guide</div>
    </div>
    <nav class="sidebar-nav">
  
        <div class="nav-part">
          <div class="nav-part-title">Frontmatter</div>
          <ul class="nav-chapters">
      
          <li>
            <a href="/00-frontmatter/00-preface.html" class="">
              <span class="chapter-number">•</span>
              Preface
            </a>
          </li>
        
          <li>
            <a href="/00-frontmatter/01-how-to-use-this-book.html" class="">
              <span class="chapter-number">•</span>
              How to Use This Book
            </a>
          </li>
        
          <li>
            <a href="/00-frontmatter/02-prerequisites.html" class="">
              <span class="chapter-number">•</span>
              Prerequisites
            </a>
          </li>
        
          <li>
            <a href="/00-frontmatter/03-setup-instructions.html" class="">
              <span class="chapter-number">•</span>
              Setup Instructions
            </a>
          </li>
        
          </ul>
        </div>
      
        <div class="nav-part">
          <div class="nav-part-title">Part I: Foundations</div>
          <ul class="nav-chapters">
      
          <li>
            <a href="/01-fundamentals/01-what-is-dspy.html" class="active">
              <span class="chapter-number">1</span>
              1. What is DSPy?
            </a>
          </li>
        
          <li>
            <a href="/01-fundamentals/02-getting-started.html" class="">
              <span class="chapter-number">2</span>
              2. Getting Started
            </a>
          </li>
        
          <li>
            <a href="/01-fundamentals/03-first-program.html" class="">
              <span class="chapter-number">3</span>
              3. Your First Program
            </a>
          </li>
        
          </ul>
        </div>
      
        <div class="nav-part">
          <div class="nav-part-title">Part II: Core Concepts</div>
          <ul class="nav-chapters">
      
          <li>
            <a href="/02-core-concepts/01-signatures.html" class="">
              <span class="chapter-number">4</span>
              4. Signatures
            </a>
          </li>
        
          <li>
            <a href="/02-core-concepts/02-modules.html" class="">
              <span class="chapter-number">5</span>
              5. Modules
            </a>
          </li>
        
          <li>
            <a href="/02-core-concepts/03-composition.html" class="">
              <span class="chapter-number">6</span>
              6. Composition
            </a>
          </li>
        
          </ul>
        </div>
      
    </nav>
  
    </nav>

    <div class="page-wrapper">
      <div class="chapter-progress">
        <div class="bar"></div>
      </div>

      <div class="content">
        <h1>1. What is DSPy?</h1>
        <h1 id="what-is-dspy" tabindex="-1">What is DSPy?</h1>
<p>DSPy (Declarative Self-improving Language Programs, yeah!) is a framework for programming—not prompting—foundation models like GPT-4, Claude, and others. It provides a systematic way to build LM-based applications that are modular, composable, and automatically optimizable.</p>
<h2 id="historical-context-the-demonstrate-search-predict-paper" tabindex="-1">Historical Context: The Demonstrate-Search-Predict Paper</h2>
<p>DSPy originated from the groundbreaking research paper <strong>“Demonstrate-Search-Predict: A Paradigm for Solving Complex, Multi-Hop Reasoning Tasks with Large Language Models”</strong> by Omar Khattab and colleagues at Stanford University. This work established the foundational principles that would evolve into the DSPy framework.</p>
<p>The paper demonstrated that complex reasoning tasks could be decomposed into three systematic stages:</p>
<ol>
<li><strong>DEMONSTRATE</strong>: Learning from examples and demonstrations</li>
<li><strong>SEARCH</strong>: Retrieving and synthesizing information from multiple sources</li>
<li><strong>PREDICT</strong>: Generating accurate outputs based on gathered evidence</li>
</ol>
<p>This three-stage approach showed that by treating language model tasks as structured programs rather than mere prompts, we could achieve:</p>
<ul>
<li>Better compositional generalization</li>
<li>More reliable multi-hop reasoning</li>
<li>Systematic optimization through weak supervision</li>
<li>Zero-shot transfer to new tasks</li>
</ul>
<p>The research proved that moving from ad-hoc prompt engineering to structured programming was the key to building reliable LM applications. DSPy is the production-ready implementation of these research insights, providing the tools and abstractions needed to build complex language model programs at scale.</p>
<hr>
<h2 id="the-problem-manual-prompt-engineering" tabindex="-1">The Problem: Manual Prompt Engineering</h2>
<p>Before understanding DSPy, let’s look at the traditional approach to working with LLMs.</p>
<h3 id="traditional-prompt-engineering" tabindex="-1">Traditional Prompt Engineering</h3>
<p>When you want an LLM to perform a task, you typically write a prompt:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> openai

<span class="hljs-comment"># Manual prompt for question answering</span>
prompt = <span class="hljs-string">&quot;&quot;&quot;
You are a knowledgeable assistant. Answer the following question accurately and concisely.

Question: What is the capital of France?

Provide your answer in a single sentence.
&quot;&quot;&quot;</span>

response = openai.chat.completions.create(
    model=<span class="hljs-string">&quot;gpt-4&quot;</span>,
    messages=[{<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: prompt}]
)

<span class="hljs-built_in">print</span>(response.choices[<span class="hljs-number">0</span>].message.content)
</code></pre>
<p>This works for simple cases, but scaling this approach leads to significant problems.</p>
<hr>
<h2 id="problems-with-manual-prompting" tabindex="-1">Problems with Manual Prompting</h2>
<h3 id="1-brittle-and-hard-to-maintain" tabindex="-1">1. <strong>Brittle and Hard to Maintain</strong></h3>
<pre><code class="hljs language-python"><span class="hljs-comment"># Prompt for sentiment analysis</span>
sentiment_prompt = <span class="hljs-string">&quot;&quot;&quot;
Analyze the sentiment of this text and classify it as positive, negative, or neutral.
Be careful to consider context and sarcasm.
Respond with only the sentiment label.

Text: {text}
Sentiment:
&quot;&quot;&quot;</span>
</code></pre>
<p><strong>Issues</strong>:</p>
<ul>
<li>What if the model doesn’t follow the “only label” instruction?</li>
<li>How do you handle edge cases consistently?</li>
<li>Changes require manual testing of the entire prompt</li>
</ul>
<h3 id="2-doesn-t-compose-well" tabindex="-1">2. <strong>Doesn’t Compose Well</strong></h3>
<p>Suppose you want to chain multiple steps:</p>
<pre><code class="hljs language-python"><span class="hljs-comment"># Step 1: Summarize</span>
summary_prompt = <span class="hljs-string">f&quot;Summarize this: <span class="hljs-subst">{document}</span>&quot;</span>
summary = call_llm(summary_prompt)

<span class="hljs-comment"># Step 2: Extract entities</span>
entity_prompt = <span class="hljs-string">f&quot;Extract entities from: <span class="hljs-subst">{summary}</span>&quot;</span>
entities = call_llm(entity_prompt)

<span class="hljs-comment"># Step 3: Classify</span>
classification_prompt = <span class="hljs-string">f&quot;Classify these entities: <span class="hljs-subst">{entities}</span>&quot;</span>
result = call_llm(classification_prompt)
</code></pre>
<p><strong>Issues</strong>:</p>
<ul>
<li>Error propagation through the pipeline</li>
<li>No systematic way to optimize the entire flow</li>
<li>Debugging is a nightmare</li>
</ul>
<h3 id="3-no-systematic-optimization" tabindex="-1">3. <strong>No Systematic Optimization</strong></h3>
<p>How do you improve this?</p>
<pre><code class="hljs language-python">qa_prompt = <span class="hljs-string">&quot;&quot;&quot;
Answer the question based on the context.

Context: {context}
Question: {question}
Answer:
&quot;&quot;&quot;</span>
</code></pre>
<p><strong>Manual approach</strong>:</p>
<ul>
<li>Try different phrasings</li>
<li>Add examples manually</li>
<li>Test each variation</li>
<li>No guarantee of improvement</li>
</ul>
<p>This is like trying to train a neural network by manually adjusting weights!</p>
<hr>
<h2 id="the-solution-dspy" tabindex="-1">The Solution: DSPy</h2>
<p>DSPy changes the game by letting you <strong>program</strong> with language models instead of <strong>prompting</strong> them.</p>
<h3 id="key-idea-separate-what-from-how" tabindex="-1">Key Idea: Separate What from How</h3>
<p>Instead of telling the model <em>how</em> to solve a task (via prompts), you tell it <em>what</em> to do (via signatures), and DSPy figures out <em>how</em>.</p>
<p><strong>Traditional prompting</strong> (imperative):</p>
<pre><code class="hljs language-python">prompt = <span class="hljs-string">&quot;You are an assistant. Answer questions. Question: {q}&quot;</span>
</code></pre>
<p><strong>DSPy</strong> (declarative):</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">QuestionAnswer</span>(dspy.Signature):
    <span class="hljs-string">&quot;&quot;&quot;Answer questions accurately.&quot;&quot;&quot;</span>
    question: <span class="hljs-built_in">str</span> = dspy.InputField()
    answer: <span class="hljs-built_in">str</span> = dspy.OutputField()
</code></pre>
<p>DSPy automatically creates the prompts for you!</p>
<hr>
<h2 id="what-dspy-provides" tabindex="-1">What DSPy Provides</h2>
<h3 id="1-signatures-task-specifications" tabindex="-1">1. <strong>Signatures</strong>: Task Specifications</h3>
<p>Signatures define <em>what</em> a task does, not <em>how</em>:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> dspy

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Summarize</span>(dspy.Signature):
    <span class="hljs-string">&quot;&quot;&quot;Summarize the given text.&quot;&quot;&quot;</span>
    document: <span class="hljs-built_in">str</span> = dspy.InputField()
    summary: <span class="hljs-built_in">str</span> = dspy.OutputField(desc=<span class="hljs-string">&quot;concise summary in 2-3 sentences&quot;</span>)
</code></pre>
<p>This is like a type signature in programming—it specifies inputs and outputs.</p>
<h3 id="2-modules-composable-components" tabindex="-1">2. <strong>Modules</strong>: Composable Components</h3>
<p>Modules are reusable components that use signatures:</p>
<pre><code class="hljs language-python"><span class="hljs-comment"># Create a summarization module</span>
summarizer = dspy.Predict(Summarize)

<span class="hljs-comment"># Use it</span>
result = summarizer(document=<span class="hljs-string">&quot;Long text here...&quot;</span>)
<span class="hljs-built_in">print</span>(result.summary)
</code></pre>
<p>Modules can be combined, extended, and optimized.</p>
<h3 id="3-optimizers-automatic-improvement" tabindex="-1">3. <strong>Optimizers</strong>: Automatic Improvement</h3>
<p>This is where DSPy shines—you can automatically optimize your programs:</p>
<pre><code class="hljs language-python"><span class="hljs-comment"># Define your program</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">RAGPipeline</span>(dspy.Module):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>.retrieve = dspy.Retrieve(k=<span class="hljs-number">3</span>)
        <span class="hljs-variable language_">self</span>.answer = dspy.ChainOfThought(QuestionAnswer)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, question</span>):
        context = <span class="hljs-variable language_">self</span>.retrieve(question).passages
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.answer(context=context, question=question)

<span class="hljs-comment"># Optimize it automatically</span>
<span class="hljs-keyword">from</span> dspy.teleprompt <span class="hljs-keyword">import</span> BootstrapFewShot

optimizer = BootstrapFewShot(metric=your_metric)
optimized_rag = optimizer.<span class="hljs-built_in">compile</span>(RAGPipeline(), trainset=your_data)
</code></pre>
<p>DSPy learns better prompts, better examples, and better module compositions!</p>
<hr>
<h2 id="core-concepts" tabindex="-1">Core Concepts</h2>
<h3 id="signatures" tabindex="-1">Signatures</h3>
<p>Think of signatures as function declarations for LM tasks:</p>
<pre><code class="hljs language-python"><span class="hljs-comment"># Input -&gt; Output specification</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">TranslateToFrench</span>(dspy.Signature):
    english_text: <span class="hljs-built_in">str</span> = dspy.InputField()
    french_text: <span class="hljs-built_in">str</span> = dspy.OutputField()
</code></pre>
<h3 id="modules" tabindex="-1">Modules</h3>
<p>Pre-built and custom components:</p>
<ul>
<li><strong><code>dspy.Predict</code></strong>: Basic prediction</li>
<li><strong><code>dspy.ChainOfThought</code></strong>: Step-by-step reasoning</li>
<li><strong><code>dspy.ReAct</code></strong>: Agent-style reasoning with tools</li>
<li><strong>Custom</strong>: Build your own!</li>
</ul>
<h3 id="teleprompters-optimizers" tabindex="-1">Teleprompters (Optimizers)</h3>
<p>Automatically improve your program:</p>
<ul>
<li><strong><code>BootstrapFewShot</code></strong>: Generate few-shot examples</li>
<li><strong><code>MIPRO</code></strong>: Optimize instructions and demonstrations</li>
<li><strong><code>KNNFewShot</code></strong>: Use similarity-based examples</li>
</ul>
<hr>
<h2 id="a-simple-example" tabindex="-1">A Simple Example</h2>
<p>Let’s compare traditional prompting with DSPy:</p>
<h3 id="traditional-approach" tabindex="-1">Traditional Approach</h3>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> openai

<span class="hljs-keyword">def</span> <span class="hljs-title function_">answer_question</span>(<span class="hljs-params">question</span>):
    prompt = <span class="hljs-string">f&quot;&quot;&quot;
    You are a helpful assistant. Answer this question accurately:

    Question: <span class="hljs-subst">{question}</span>

    Provide a clear, concise answer.
    &quot;&quot;&quot;</span>

    response = openai.chat.completions.create(
        model=<span class="hljs-string">&quot;gpt-4&quot;</span>,
        messages=[{<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: prompt}]
    )

    <span class="hljs-keyword">return</span> response.choices[<span class="hljs-number">0</span>].message.content

<span class="hljs-comment"># Use it</span>
answer = answer_question(<span class="hljs-string">&quot;What is machine learning?&quot;</span>)
<span class="hljs-built_in">print</span>(answer)
</code></pre>
<h3 id="dspy-approach" tabindex="-1">DSPy Approach</h3>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> dspy

<span class="hljs-comment"># Configure the language model</span>
lm = dspy.LM(model=<span class="hljs-string">&quot;openai/gpt-4&quot;</span>)
dspy.configure(lm=lm)

<span class="hljs-comment"># Define the task</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">QuestionAnswer</span>(dspy.Signature):
    <span class="hljs-string">&quot;&quot;&quot;Answer questions accurately.&quot;&quot;&quot;</span>
    question: <span class="hljs-built_in">str</span> = dspy.InputField()
    answer: <span class="hljs-built_in">str</span> = dspy.OutputField()

<span class="hljs-comment"># Create the module</span>
qa = dspy.Predict(QuestionAnswer)

<span class="hljs-comment"># Use it</span>
answer = qa(question=<span class="hljs-string">&quot;What is machine learning?&quot;</span>)
<span class="hljs-built_in">print</span>(answer.answer)
</code></pre>
<p><strong>Benefits of the DSPy version</strong>:</p>
<ul>
<li>✅ More modular and reusable</li>
<li>✅ Can be composed with other modules</li>
<li>✅ Can be automatically optimized</li>
<li>✅ Prompts are generated automatically</li>
<li>✅ Easier to maintain and test</li>
</ul>
<hr>
<h2 id="why-dspy-matters" tabindex="-1">Why DSPy Matters</h2>
<h3 id="1-systematic-development" tabindex="-1">1. <strong>Systematic Development</strong></h3>
<p>DSPy brings software engineering practices to LM applications:</p>
<ul>
<li>Modularity and composition</li>
<li>Abstraction and reusability</li>
<li>Systematic testing and optimization</li>
</ul>
<h3 id="2-automatic-optimization" tabindex="-1">2. <strong>Automatic Optimization</strong></h3>
<p>Instead of manually tweaking prompts:</p>
<ul>
<li>DSPy learns from your data</li>
<li>Generates optimal prompts</li>
<li>Improves with more examples</li>
</ul>
<h3 id="3-scalability" tabindex="-1">3. <strong>Scalability</strong></h3>
<p>Build complex pipelines that:</p>
<ul>
<li>Chain multiple steps</li>
<li>Handle errors gracefully</li>
<li>Scale to production</li>
</ul>
<h3 id="4-research-backed" tabindex="-1">4. <strong>Research-Backed</strong></h3>
<p>DSPy is developed by Stanford NLP and backed by research:</p>
<ul>
<li>Published at NeurIPS, NAACL, and other top venues</li>
<li>Proven effectiveness across tasks</li>
<li>Active research community</li>
</ul>
<hr>
<h2 id="real-world-use-cases" tabindex="-1">Real-World Use Cases</h2>
<p>DSPy excels at:</p>
<h3 id="question-answering-systems" tabindex="-1">Question Answering Systems</h3>
<pre><code class="hljs language-python"><span class="hljs-comment"># RAG-based QA</span>
retriever = dspy.Retrieve(k=<span class="hljs-number">3</span>)
qa = dspy.ChainOfThought(<span class="hljs-string">&quot;context, question -&gt; answer&quot;</span>)
</code></pre>
<h3 id="multi-step-reasoning" tabindex="-1">Multi-Step Reasoning</h3>
<pre><code class="hljs language-python"><span class="hljs-comment"># Complex analysis pipelines</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">AnalysisPipeline</span>(dspy.Module):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>.extract = dspy.Predict(<span class="hljs-string">&quot;text -&gt; entities&quot;</span>)
        <span class="hljs-variable language_">self</span>.classify = dspy.ChainOfThought(<span class="hljs-string">&quot;entities -&gt; category&quot;</span>)
        <span class="hljs-variable language_">self</span>.summarize = dspy.Predict(<span class="hljs-string">&quot;entities, category -&gt; summary&quot;</span>)
</code></pre>
<h3 id="agents-and-tools" tabindex="-1">Agents and Tools</h3>
<pre><code class="hljs language-python"><span class="hljs-comment"># ReAct-style agents</span>
agent = dspy.ReAct(<span class="hljs-string">&quot;question -&gt; answer&quot;</span>, tools=[search, calculator])
</code></pre>
<hr>
<h2 id="dspy-vs-other-frameworks" tabindex="-1">DSPy vs. Other Frameworks</h2>
<h3 id="vs-langchain" tabindex="-1">vs. LangChain</h3>
<p><strong>LangChain</strong>: Focuses on orchestration and integrations
<strong>DSPy</strong>: Focuses on optimization and systematic improvement</p>
<p>DSPy complements LangChain—you can use both together!</p>
<h3 id="vs-guidance-lmql" tabindex="-1">vs. Guidance/LMQL</h3>
<p><strong>Guidance/LMQL</strong>: Template-based prompt control
<strong>DSPy</strong>: Automatic prompt generation and optimization</p>
<p>DSPy abstracts away the prompt engineering entirely.</p>
<h3 id="vs-direct-api-calls" tabindex="-1">vs. Direct API Calls</h3>
<p><strong>Direct APIs</strong>: Maximum control, maximum effort
<strong>DSPy</strong>: Abstraction with automatic optimization</p>
<p>DSPy is higher-level but more powerful for complex tasks.</p>
<hr>
<h2 id="when-to-use-dspy" tabindex="-1">When to Use DSPy</h2>
<p><strong>DSPy is ideal when you</strong>:</p>
<ul>
<li>✅ Build complex LM pipelines with multiple steps</li>
<li>✅ Want to systematically improve performance</li>
<li>✅ Need modularity and reusability</li>
<li>✅ Have data for optimization</li>
<li>✅ Value maintainability over quick hacks</li>
</ul>
<p><strong>Consider alternatives when you</strong>:</p>
<ul>
<li>❌ Need a simple one-off query</li>
<li>❌ Have zero data for optimization</li>
<li>❌ Need very specific prompt control</li>
<li>❌ Require guaranteed output formats (use Guidance/LMQL)</li>
</ul>
<hr>
<h2 id="the-dspy-philosophy" tabindex="-1">The DSPy Philosophy</h2>
<h3 id="programming-prompting" tabindex="-1">Programming &gt; Prompting</h3>
<pre><code class="hljs"><span class="hljs-symbol">Traditional:</span>  Human writes prompt → LM executes → Human tweaks prompt → Repeat
<span class="hljs-symbol">DSPy:</span>         Human defines task → DSPy optimizes → LM executes → System improves
</code></pre>
<h3 id="declarative-imperative" tabindex="-1">Declarative &gt; Imperative</h3>
<pre><code class="hljs"><span class="hljs-symbol">Imperative:</span>   <span class="hljs-string">&quot;Here&#x27;s how to answer: First read the context, then...&quot;</span>
<span class="hljs-symbol">Declarative:</span>  <span class="hljs-string">&quot;Given context and question, produce an answer&quot;</span>
</code></pre>
<h3 id="structured-reasoning-flat-prompts" tabindex="-1">Structured Reasoning &gt; Flat Prompts</h3>
<p>The Demonstrate-Search-Predict paradigm gives us:</p>
<pre><code class="hljs"><span class="hljs-symbol">DEMONSTRATE:</span> Learn <span class="hljs-keyword">from</span> examples → Build task understanding
<span class="hljs-symbol">SEARCH:</span>      Retrieve evidence → Gather relevant information
<span class="hljs-symbol">PREDICT:</span>     Generate output → Produce final answer
</code></pre>
<h3 id="optimizable-static" tabindex="-1">Optimizable &gt; Static</h3>
<pre><code class="hljs">Static:       Fixed prompts <span class="hljs-literal">that</span> <span class="hljs-built_in">require</span> manual updates
Optimizable:  Programs <span class="hljs-literal">that</span> improve automatically <span class="hljs-keyword">from</span> data
</code></pre>
<hr>
<h2 id="summary" tabindex="-1">Summary</h2>
<p><strong>DSPy is</strong>:</p>
<ul>
<li>A framework for programming foundation models</li>
<li>Based on signatures (task specs) and modules (components)</li>
<li>Designed for composition and optimization</li>
<li>Research-backed and production-ready</li>
</ul>
<p><strong>DSPy lets you</strong>:</p>
<ul>
<li>Define <em>what</em> tasks do, not <em>how</em></li>
<li>Build modular, composable pipelines</li>
<li>Automatically optimize from data</li>
<li>Scale to complex applications</li>
</ul>
<p><strong>Key Advantage</strong>:
Instead of manually engineering prompts, you program at a higher level and let DSPy handle the prompt optimization automatically.</p>
<hr>
<h2 id="next-steps" tabindex="-1">Next Steps</h2>
<p>Now that you understand what DSPy is, let’s dive deeper into the paradigm shift it represents.</p>
<p><strong>Continue to</strong>: <a href="02-programming-vs-prompting.md">Programming vs. Prompting</a></p>
<hr>
<h2 id="additional-resources" tabindex="-1">Additional Resources</h2>
<ul>
<li><strong>DSPy Paper</strong>: <a href="https://arxiv.org/abs/2310.03714">Compiling Declarative Language Model Calls into Self-Improving Pipelines</a></li>
<li><strong>DSPy Website</strong>: <a href="https://dspy.ai">https://dspy.ai</a></li>
<li><strong>DSPy GitHub</strong>: <a href="https://github.com/stanfordnlp/dspy">https://github.com/stanfordnlp/dspy</a></li>
<li><strong>Blog Post</strong>: <a href="https://dspy.ai/blog/">Intro to DSPy</a></li>
</ul>


        <div class="page-nav-buttons">
          
      <a href="/00-frontmatter/03-setup-instructions.html" class="nav-button prev">
        <span class="direction">Previous</span>
        <span class="arrow">←</span>
      </a>
    
      <a href="/01-fundamentals/02-getting-started.html" class="nav-button next">
        <span class="arrow">→</span>
        <span class="direction">Next</span>
      </a>
    
        </div>
      </div>
    </div>
  
    </div>
    <script src="/assets/js/navigation.js"></script>
    <script src="/assets/js/main.js"></script>
</body>
</html>